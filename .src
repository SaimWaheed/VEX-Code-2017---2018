#pragma config(Sensor, dgtl1,  EncoderL,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  EncoderR,       sensorQuadEncoder)
#pragma config(Motor,  port2,           leftDirect,    tmotorVex393HighSpeed_MC29, PIDControl, encoderPort, dgtl1)
#pragma config(Motor,  port3,           leftChain,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           rightDirect,   tmotorVex393HighSpeed_MC29, PIDControl, encoderPort, dgtl3)
#pragma config(Motor,  port5,           rightChain,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           TM,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           mgmLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           mgmRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Claw,          tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)
#pragma platform(VEX2)
#include "VEX_competition_Includes.c"

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

task autonomous()
{
  int tenthsOfIn = 480;
  int tickGoal = (42 * tenthsOfIn) / 10;
  int masterPower = 100;

  //This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
  int totalTicks = 0;

  //Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The
  //-5 value is based off a rough guess of how much the motors are different, which prevents the robot from
  //veering off course at the start of the function.
  int slavePower = masterPower - 5;

  int error = 0;

  int kp = 5;
  SensorValue[EncoderL] = 0;
  SensorValue[EncoderR] = 0;

  //Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.
  while(abs(totalTicks) < tickGoal)
  {
    //Proportional algorithm to keep the robot going straight.
    motor[leftDirect] = motor[leftChain] = masterPower;
    motor[rightDirect] = motor[rightChain] = slavePower;

    error = SensorValue[EncoderL] - SensorValue[EncoderR];

    slavePower += error / kp;

    SensorValue[EncoderL] = 0;
    SensorValue[EncoderR] = 0;

    wait1Msec(100);

    //Add this iteration's encoder values to totalTicks.
    totalTicks+= SensorValue[EncoderL];
  }
  motor[leftChain] = motor[leftDirect] = 0; // Stop the loop once the encoders have counted up the correct number of encoder ticks.
  motor[rightChain] = motor[rightDirect] = 0;


}
task usercontrol()
{
	while(true)
	{

//	motor[BLDT] = vexRT[Ch3] ( BLDT = Back Left Drive Train )

//	motor[FLDT] = vexRT[Ch3] ( FLDT = Forward Left Drive Train )

//	motor[BRDT] = vexRT[Ch2] ( BRDT = Back Right Drive Train )

//	motor[FRDT] = vexRT[Ch2] ( FRDT = Forward Right Drive Train )

//	motor[LOTLIT] = vexRT[Btn6U] or vexRT[Btn6D]( LOTLIT = Left Outer Tower / Left Inner Tower )

//  motor[ROTRIT] = vexRT[Btn6U] or vexRT[Btn6D]( ROTRIT = Right Outer Tower / Right Inner Tower )

//	motor[Claw] = vexRT[Btn7U] or vexRT[Btn7D] ( Claw = Claw )

// ------------------------------ Start Of Left Drive Train -------------------------------------------------------------------------------------------------------------------------------------------------

	if( abs ( vexRT[Ch3] ) > 20 ) // Check if the absolute value of the input of Channel 2 (Ch2) is greater than 20 (thld)
			motor[leftChain] = motor[leftDirect] = vexRT[Ch3]; // If it is, make the Back-Right-Drive-Train (BRDT) equal to the Forward-Right-Drive-Train and set them equal to the speed of Channel 2 (Ch2)
	else // If the value of Channel 2 (Ch2) is not greater than 20 (thld)
			motor[leftChain] = motor[leftDirect] = 0; // Make the Back-Right-Drive-Train (BRDT) equal to the Forward-Right-Drive-Train (FRDT) and set them equal to 0 speed

 // ----------------- End Of Left Drive Train -- Start Of Right Drive Train ---------------------------------------------------------------------------------------------------------------------------------

	if( abs ( vexRT[Ch2] ) > 20 ) // Check if the absolute value of the input of Channel 3 (Ch3) is greater than 20 (thld)
			motor[rightChain] = motor[rightDirect] = vexRT[Ch2]; //  If it is, make the Back-Left-Drive-Train (BLDT) equal to the Forward-Left-Drive-Train (FLDR) and set them equal to the speed of Channel 3 (Ch3)
	else // If the value of Channel 3 (Ch3) is not greater than 20 (thld)
			motor[rightChain] = motor[rightDirect] = 0; // Make the Back-Left-Drive-Train (BLDT) equal to the Forward-Left-Drive-Train (FLDT) and set them equal to 0 speed

// ------------------------------ End Of Right Drive Train -------------------------------------------------------------------------------------------------------------------------------------------------
	if( vexRT[Btn6U] == 1) // Check if the absolute value of the input of Channel 2 (Ch2) is greater than 20 (thld)
			motor[mgmLeft] = motor[mgmRight] = 127; // If it is, make the Back-Right-Drive-Train (BRDT) equal to the Forward-Right-Drive-Train and set them equal to the speed of Channel 2 (Ch2)

if( vexRT[Btn6D] == 1) // Check if the absolute value of the input of Channel 2 (Ch2) is greater than 20 (thld)
			motor[mgmLeft] = motor[mgmRight] = -127; // If it is, make the Back-Right-Drive-Train (BRDT) equal to the Forward-Right-Drive-Train and set them equal to the speed of Channel 2 (Ch2)

if( vexRT[Btn6U]==0 && vexRT[Btn6D] == 0 )// If the value of Channel 2 (Ch2) is not greater than 20 (thld)
			motor[mgmLeft] = motor[mgmRight] = 0;// Make the Back-Right-Drive-Train (BRDT) equal to the Forward-Right-Drive-Train (FRDT) and set them equal to 0 speed
if( vexRT[Btn5U] == 1) // Check if the absolute value of the input of Channel 2 (Ch2) is greater than 20 (thld)
			motor[TM] = 127; // If it is, make the Back-Right-Drive-Train (BRDT) equal to the Forward-Right-Drive-Train and set them equal to the speed of Channel 2 (Ch2)

if( vexRT[Btn5D] == 1) // Check if the absolute value of the input of Channel 2 (Ch2) is greater than 20 (thld)
			motor[TM] = -127; // If it is, make the Back-Right-Drive-Train (BRDT) equal to the Forward-Right-Drive-Train and set them equal to the speed of Channel 2 (Ch2)

if( vexRT[Btn5U]==0 && vexRT[Btn5D] == 0 )// If the value of Channel 2 (Ch2) is not greater than 20 (thld)
			motor[TM] = 0;
if( vexRT[Btn7U] == 1) // Check if the absolute value of the input of Channel 2 (Ch2) is greater than 20 (thld)
			motor[Claw] =  127; // If it is, make the Back-Right-Drive-Train (BRDT) equal to the Forward-Right-Drive-Train and set them equal to the speed of Channel 2 (Ch2)

if( vexRT[Btn7D] == 1) // Check if the absolute value of the input of Channel 2 (Ch2) is greater than 20 (thld)
			motor[Claw] = -127; // If it is, make the Back-Right-Drive-Train (BRDT) equal to the Forward-Right-Drive-Train and set them equal to the speed of Channel 2 (Ch2)

if( vexRT[Btn7U]==0 && vexRT[Btn7D] == 0 )// If the value of Channel 2 (Ch2) is not greater than 20 (thld)
			motor[Claw] = 0;
 // ----------------- End Of Left Drive Train -- Start Of Right Drive Train ---------------------------------------------------------------------------------------------------------------------------------
			}
}
