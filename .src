#pragma config(Sensor, dgtl1,  EncoderL,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  EncoderR,       sensorQuadEncoder)
#pragma config(Motor,  port2,           LOTLIT,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           ROTRIT,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           FLDT,          tmotorVex393_MC29, PIDControl, encoderPort, dgtl1)
#pragma config(Motor,  port5,           BLDT,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           FRDT,          tmotorVex393_MC29, PIDControl, reversed, encoderPort, dgtl3)
#pragma config(Motor,  port7,           BRDT,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           Claw,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)
#pragma platform(VEX2)
#include "VEX_competition_Includes.c"



/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
/*	int rotationNumberL, rotationNumberR;
	int rotationCountL = SensorValue[EncoderL];
	int rotationCountR = SensorValue[EncoderR];
	motor[Claw] = 100;
	wait1Msec(1500);
	motor[Claw] = 0;
	motor[ROTRIT] = motor[LOTLIT] = 127;
	wait1Msec(3000);
	motor[ROTRIT] = motor[LOTLIT] = 0;
  while (rotationCountL < rotationNumberL && rotationCountR < rotationNumberR)
  {
  	motor[BLDT] = 100;
	
		motor[FLDT] = 100;
	
		motor[BRDT] = 100;
	
		motor[FRDT] = 100;
	
	}
  	motor[BLDT] = 0;
	
		motor[FLDT] = 0;
	
		motor[BRDT] = 0;
	
		motor[FRDT] = 0;
}
*/
//http://www.robotc.net/wikiarchive/Tutorials/Arduino_Projects/Mobile_Robotics/VEX/Using_encoders_to_drive_straight helped create below autonomous code
//Below Autonomous code makes robot pick up a cone, lift it, drive forward 4 feet, put it down, then let go and lift up 
  int tenthsOfIn = 480;
  int tickGoal = (42 * tenthsOfIn) / 10;
  int masterPower = 100;
 
  //This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
  int totalTicks = 0;
 
  //Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The
  //-5 value is based off a rough guess of how much the motors are different, which prevents the robot from
  //veering off course at the start of the function.
  int slavePower = masterPower - 5; 
 
  int error = 0;
 
  int kp = 5;
  
  motor[Claw] = 100;
	wait1Msec(1500);
	motor[Claw] = 0;
	motor[ROTRIT] = motor[LOTLIT] = 127;
	wait1Msec(3000);
	motor[ROTRIT] = motor[LOTLIT] = 0;
 
  SensorValue[EncoderL] = 0;
  SensorValue[EncoderR] = 0;
 
  //Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.
  while(abs(totalTicks) < tickGoal)
  {
    //Proportional algorithm to keep the robot going straight.
    motor[BLDT] = motor[FLDT] = masterPower;
    motor[BRDT] = motor[FRDT] = slavePower;
 
    error = SensorValue[EncoderL] - SensorValue[EncoderR];
 
    slavePower += error / kp;
 
    SensorValue[EncoderL] = 0;
    SensorValue[EncoderR] = 0;
 
    wait1Msec(100);
 
    //Add this iteration's encoder values to totalTicks.
    totalTicks+= SensorValue[leftEncoder];
    if (Btn8R == 1){
    	break;
    }
  }
  motor[BLDT] = motor[FLDT] = 0; // Stop the loop once the encoders have counted up the correct number of encoder ticks.
  motor[BRDT] = motor[FRDT] = 0;
  motor[Claw] = -100;
	wait1Msec(1500);
	motor[Claw] = 0;
	motor[ROTRIT] = motor[LOTLIT] = -127;
	wait1Msec(3000);
	motor[ROTRIT] = motor[LOTLIT] = 0;
  
}
task usercontrol()
{
	while(true)
	{

//	motor[BLDT] = vexRT[Ch3] ( BLDT = Back Left Drive Train )
	
//	motor[FLDT] = vexRT[Ch3] ( FLDT = Forward Left Drive Train )
	
//	motor[BRDT] = vexRT[Ch2] ( BRDT = Back Right Drive Train )
	
//	motor[FRDT] = vexRT[Ch2] ( FRDT = Forward Right Drive Train )
	
//	motor[LOTLIT] = vexRT[Btn6U] or vexRT[Btn6D]( LOTLIT = Left Outer Tower / Left Inner Tower )
	
//  motor[ROTRIT] = vexRT[Btn6U] or vexRT[Btn6D]( ROTRIT = Right Outer Tower / Right Inner Tower )
	
//	motor[Claw] = vexRT[Btn7U] or vexRT[Btn7D] ( Claw = Claw )

// ------------------------------ Start Of Left Drive Train -------------------------------------------------------------------------------------------------------------------------------------------------

	if( abs ( vexRT[Ch2] ) > 20 ) // Check if the absolute value of the input of Channel 2 (Ch2) is greater than 20 (thld)
			motor[BRDT] = motor[FRDT] = vexRT[Ch2]; // If it is, make the Back-Right-Drive-Train (BRDT) equal to the Forward-Right-Drive-Train and set them equal to the speed of Channel 2 (Ch2)
	else // If the value of Channel 2 (Ch2) is not greater than 20 (thld)
			motor[BRDT] = motor[FRDT] = 0; // Make the Back-Right-Drive-Train (BRDT) equal to the Forward-Right-Drive-Train (FRDT) and set them equal to 0 speed

 // ----------------- End Of Left Drive Train -- Start Of Right Drive Train ---------------------------------------------------------------------------------------------------------------------------------

	if( abs ( vexRT[Ch3] ) > 20 ) // Check if the absolute value of the input of Channel 3 (Ch3) is greater than 20 (thld)
			motor[BLDT] = motor[FLDT] = vexRT[Ch3]; //  If it is, make the Back-Left-Drive-Train (BLDT) equal to the Forward-Left-Drive-Train (FLDR) and set them equal to the speed of Channel 3 (Ch3)
	else // If the value of Channel 3 (Ch3) is not greater than 20 (thld)
			motor[BLDT] = motor[FLDT] = 0; // Make the Back-Left-Drive-Train (BLDT) equal to the Forward-Left-Drive-Train (FLDT) and set them equal to 0 speed

// ------------------------------ End Of Right Drive Train --------------------------------------------------------------------------------------------------------------------------------------------------

	if(vexRT[Btn6U] == 1) // If Button 6U is pressed
		motor[LOTLIT] = motor[ROTRIT] = 127; // Make the Left Outer Tower / Left Inner Tower (LOTLIT) equal to the Right Outer Tower / Right Inner Tower (ROTRIT) and set the speed to 127

	else if(vexRT[Btn6D] == 1) // If Button 6D is pressed
		motor[LOTLIT] = motor[ROTRIT] = -127; // Make the Left Tower equal to the Right Tower and set the speed to -127 ( Down )

	else
		motor[LOTLIT] = motor[ROTRIT] = 0;

// --------------------------- End Of Towers -- Start Of Claw  -------------------------------------------------------------------------------------------------------------------------------------------------------------

	if(vexRT[Btn5U] == 1)
		motor[Claw] = 100;

	else if(vexRT[Btn5D] == 1)
		motor[Claw] = -100;

	else
		motor[Claw] = 0;
	}
}
