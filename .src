#pragma config(Sensor, dgtl1,  EncoderL,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  EncoderR,       sensorQuadEncoder)
#pragma config(Motor,  port2,           LOTLIT,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           ROTRIT,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           FLDT,          tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           BLDT,          tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           FRDT,          tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           BRDT,          tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           Claw,          tmotorVex393_MC29, openLoop)
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)
#pragma platform(VEX2)
#include "VEX_competition_Includes.c"

/*----------------------------- Pre-Autonomous Functions -----------------------------*/


void pre_auton()
{
  bStopTasksBetweenModes = true;
}


/*----------------------------- Autonomous Functions ---------------------------------*/


task autonomous()
{
	if (vexRT[Btn8L] == 1)
	{
	  int tenthsOfIn = 480;
	  int tickGoal = (42 * tenthsOfIn) / 10;
	  int masterPower = 100;
  	int totalTicks = 0;  //This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
	  int slavePower = masterPower - 5; //Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The -5 value is based off a rough guess of how much the motors are different, which prevents the robot from veering off course at the start of the function.
	  int error = 0;
	  int kp = 5;
  
		  motor[Claw] = 100;
			wait1Msec(1500);
			
			motor[Claw] = 0;
			motor[ROTRIT] = motor[LOTLIT] = 127;
			wait1Msec(3000);
	
			motor[ROTRIT] = motor[LOTLIT] = 0;
 
		SensorValue[EncoderL] = 0;
		SensorValue[EncoderR] = 0;
		 
  
  		while(abs(totalTicks) < tickGoal) //Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.
  		{
  			error = SensorValue[EncoderL] - SensorValue[EncoderR];
			    motor[BLDT] = motor[FLDT] = masterPower; //Proportional algorithm to keep the robot going straight.
			    motor[BRDT] = motor[FRDT] = slavePower; //Proportional algorithm to keep the robot going straight.
			    
		    	slavePower += error / kp;
		 
		    SensorValue[EncoderL] = 0;
		    SensorValue[EncoderR] = 0;
		    	wait1Msec(100);
		    	totalTicks += SensorValue[EncoderL]; //Add this iteration's encoder values to totalTicks.
		  }
		  
		  
			motor[BLDT] = motor[FLDT] = 0; // Stop the loop once the encoders have counted up the correct number of encoder ticks.
			motor[BRDT] = motor[FRDT] = 0;
			motor[ROTRIT] = motor[LOTLIT] = -127;
				wait1Msec(3000);
				
			motor[ROTRIT] = motor[LOTLIT] = 0;
			motor[Claw] = -100;
				wait1Msec(1500);
			motor[Claw] = 0;			
	}
}


task usercontrol()
{
	while(true)
	{

//	motor[BLDT] = vexRT[Ch3] ( BLDT = Back Left Drive Train )
	
//	motor[FLDT] = vexRT[Ch3] ( FLDT = Forward Left Drive Train )
	
//	motor[BRDT] = vexRT[Ch2] ( BRDT = Back Right Drive Train )
	
//	motor[FRDT] = vexRT[Ch2] ( FRDT = Forward Right Drive Train )
	
//	motor[LOTLIT] = vexRT[Btn6U] or vexRT[Btn6D]( LOTLIT = Left Outer Tower / Left Inner Tower )
	
//  motor[ROTRIT] = vexRT[Btn6U] or vexRT[Btn6D]( ROTRIT = Right Outer Tower / Right Inner Tower )
	
//	motor[Claw] = vexRT[Btn7U] or vexRT[Btn7D] ( Claw = Claw )

// ------------------------------ Start Of Left Drive Train -------------------------------------------------------------------------------------------------------------------------------------------------

		if( abs ( vexRT[Ch2] ) > 20 ) // Check if the absolute value of the input of Channel 2 (Ch2) is greater than 20 (thld)
				motor[BRDT] = motor[FRDT] = vexRT[Ch2]; // If it is, make the Back-Right-Drive-Train (BRDT) equal to the Forward-Right-Drive-Train and set them equal to the speed of Channel 2 (Ch2)
		else // If the value of Channel 2 (Ch2) is not greater than 20 (thld)
				motor[BRDT] = motor[FRDT] = 0; // Make the Back-Right-Drive-Train (BRDT) equal to the Forward-Right-Drive-Train (FRDT) and set them equal to 0 speed
	
// ----------------- End Of Left Drive Train -- Start Of Right Drive Train ---------------------------------------------------------------------------------------------------------------------------------
	
		if( abs ( vexRT[Ch3] ) > 20 ) // Check if the absolute value of the input of Channel 3 (Ch3) is greater than 20 (thld)
				motor[BLDT] = motor[FLDT] = vexRT[Ch3]; //  If it is, make the Back-Left-Drive-Train (BLDT) equal to the Forward-Left-Drive-Train (FLDR) and set them equal to the speed of Channel 3 (Ch3)
		else // If the value of Channel 3 (Ch3) is not greater than 20 (thld)
				motor[BLDT] = motor[FLDT] = 0; // Make the Back-Left-Drive-Train (BLDT) equal to the Forward-Left-Drive-Train (FLDT) and set them equal to 0 speed
	
// ------------------------------ End Of Right Drive Train --------------------------------------------------------------------------------------------------------------------------------------------------
	
		if(vexRT[Btn6U] == 1) // If Button 6U is pressed
			motor[LOTLIT] = motor[ROTRIT] = 127; // Make the Left Outer Tower / Left Inner Tower (LOTLIT) equal to the Right Outer Tower / Right Inner Tower (ROTRIT) and set the speed to 127
	
		else if(vexRT[Btn6D] == 1) // If Button 6D is pressed
			motor[LOTLIT] = motor[ROTRIT] = -127; // Make the Left Tower equal to the Right Tower and set the speed to -127 ( Down )
	
		else
			motor[LOTLIT] = motor[ROTRIT] = 0;
	
// --------------------------- End Of Towers -- Start Of Claw  -------------------------------------------------------------------------------------------------------------------------------------------------------------
	
		if(vexRT[Btn5U] == 1)
			motor[Claw] = 100;
	
		else if(vexRT[Btn5D] == 1)
			motor[Claw] = -100;
	
		else
			motor[Claw] = 0;
	}
}
