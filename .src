#pragma config(Sensor, dgtl1,  EncoderL,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  EncoderR,       sensorQuadEncoder)
#pragma config(Motor,  port2,           leftDirect,    tmotorVex393HighSpeed_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port3,           leftChain,     tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port4,           rightDirect,   tmotorVex393HighSpeed_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port5,           rightChain,    tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, dgtl3)
#pragma config(Motor,  port6,           TM,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           mgmLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           mgmRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          Claw,          tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)
#pragma platform(VEX2)
#include "VEX_competition_Includes.c"

void pre_auton()
{
  bStopTasksBetweenModes = true;
}

task autonomous()
{
  int tenthsOfIn = 360;
  int tickGoal = (42 * tenthsOfIn) / 10;
  int masterPower = 100;

  //This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
  int totalTicks = 0;

  //Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The
  //-5 value is based off a rough guess of how much the motors are different, which prevents the robot from
  //veering off course at the start of the function.
  int slavePower = masterPower - 5;

  int error = 0;

  int kp = 5;
  SensorValue[EncoderL] = 0;
  SensorValue[EncoderR] = 0;
	
  //Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.
  while(abs(totalTicks) < tickGoal)
  {
    //Proportional algorithm to keep the robot going straight.
    motor[leftDirect] = motor[leftChain] = masterPower;
    motor[rightDirect] = motor[rightChain] = slavePower;

    error = abs(SensorValue[EncoderL]) - abs(SensorValue[EncoderR]);

    slavePower += error / kp;

    SensorValue[EncoderL] = 0;
    SensorValue[EncoderR] = 0;

    wait1Msec(100);

    //Add this iteration's encoder values to totalTicks.
    totalTicks+= abs(SensorValue[EncoderL]);
  }
  motor[leftChain] = motor[leftDirect] = 0; // Stop the loop once the encoders have counted up the correct number of encoder ticks.
  motor[rightChain] = motor[rightDirect] = 0;
  
 motor[TM] = 127;
 wait1Msec(750);
 motor[TM] = 0;
  
  motor[mgmLeft] = motor[mgmRight] = -127;
  wait1Msec(1000);
  motor[mgmLeft] = motor[mgmRight] = 0;
}
task usercontrol()
{
	while(true)
	{
		if ( abs ( vexRT[Ch2] ) > 20)
		{
			motor[rightChain] = motor[rightDirect] = vexRT[Ch2];
		}
			else
			{
				motor[rightChain] = motor[rightDirect] = 0;
			}

		if ( abs ( vexRT[Ch3] ) > 20)
		{
			motor[leftChain] = motor[leftDirect] = vexRT[Ch3];
		}
			else
			{
				motor[leftChain] = motor[leftDirect] = 0;
			}

		if( vexRT[Btn6U] == 1)
			motor[mgmLeft] = motor[mgmRight] = 127;

		if ( vexRT[Btn6D] == 1)
			motor[mgmLeft] = motor[mgmRight] = -127;

		if( vexRT[Btn6U]==0 && vexRT[Btn6D] == 0 )
			motor[mgmLeft] = motor[mgmRight] = 0;

		if( vexRT[Btn5U] == 1)
			motor[TM] = 127;

		if( vexRT[Btn5D] == 1)
			motor[TM] = -127;

		if( vexRT[Btn5U]==0 && vexRT[Btn5D] == 0 )
			motor[TM] = 0;

		if( vexRT[Btn7U] == 1)
			motor[Claw] =  127;

		if( vexRT[Btn7D] == 1)
			motor[Claw] = -127;

		if( vexRT[Btn7U]==0 && vexRT[Btn7D] == 0 )
			motor[Claw] = 0;
	}
}
